# Message Loading API Design - Discussion

## Contexte

Actuellement, le chargement de l'historique d'une conversation se fait via le **replay automatique** lors de la connexion SSE. Cela pose plusieurs probl√®mes :

### Probl√®mes identifi√©s

1. **Duplication de messages** : Si une instance Coday est d√©j√† active et a broadcast√© des messages, puis que le client se reconnecte, il re√ßoit :
   - Les messages d√©j√† re√ßus via broadcast
   - Les m√™mes messages via le replay
   - R√©sultat : duplication

2. **M√©lange de responsabilit√©s** : Le SSE endpoint g√®re √† la fois :
   - La r√©cup√©ration de l'historique (replay)
   - La souscription aux √©v√©nements temps r√©el (broadcast)

3. **Manque de contr√¥le client** : Le client ne peut pas choisir quand recharger l'historique

4. **Probl√®me avec les SummaryEvent** : Les r√©sum√©s peuvent √™tre ins√©r√©s au milieu de la chronologie, rendant impossible l'utilisation d'un simple timestamp "last received"

## Solution propos√©e : S√©paration des pr√©occupations

### Architecture cible

```
Client Thread Loading Flow:
1. GET /api/projects/:projectName/threads/:threadId/messages  ‚Üí Load full history
2. GET /api/projects/:projectName/threads/:threadId/event-stream ‚Üí Subscribe to updates

Client reconnection flow:
1. Keep existing messages in memory
2. Reconnect to event-stream (no replay)
3. Receive only new events via broadcast
4. Client-side deduplication prevents any duplicates
```

## Design de l'API `/messages`

### Option A : Messages complets (recommand√©)

```typescript
GET /api/projects/:projectName/threads/:threadId/messages

Response: {
  messages: ThreadMessage[],  // Array of all messages in chronological order
  threadInfo: {
    id: string,
    name: string,
    messageCount: number,
    modifiedDate: string
  }
}
```

**Avantages** :
- Simple √† impl√©menter
- Pas de pagination complexe au d√©part
- Client obtient l'√©tat complet du thread

**Inconv√©nients** :
- Peut devenir lourd pour les tr√®s longs threads
- Mais : la plupart des threads ont < 100 messages

### Option B : Messages avec pagination

```typescript
GET /api/projects/:projectName/threads/:threadId/messages?limit=50&offset=0

Response: {
  messages: ThreadMessage[],
  pagination: {
    total: number,
    limit: number,
    offset: number,
    hasMore: boolean
  }
}
```

**Avantages** :
- Scalable pour les longs threads
- Meilleure performance r√©seau

**Inconv√©nients** :
- Plus complexe √† impl√©menter
- Client doit g√©rer la pagination
- Peut-√™tre pr√©matur√© (YAGNI)

### Option C : Hybride - Messages r√©cents par d√©faut

```typescript
GET /api/projects/:projectName/threads/:threadId/messages?recent=true

Response: {
  messages: ThreadMessage[],  // Last 50 messages by default
  hasMore: boolean,
  totalCount: number
}

// Si besoin de tout charger :
GET /api/projects/:projectName/threads/:threadId/messages?all=true
```

**Avantages** :
- Bon compromis entre simplicit√© et scalabilit√©
- Client charge ce dont il a besoin
- Extensible vers pagination compl√®te

## Comportement du replay actuel √† modifier

### Changement dans `thread-coday-manager.ts`

```typescript
// AVANT (actuel)
addConnection(response: Response): void {
  this.connections.add(response)
  
  // Replay automatique si Coday existe
  if (this.coday) {
    this.replayThreadHistory(response)
  }
}

// APR√àS (propos√©)
addConnection(response: Response): void {
  this.connections.add(response)
  
  // NE PLUS faire de replay automatique
  // Le client charge l'historique via GET /messages s'il en a besoin
}
```

### Avantages du changement

1. **SSE devient pur temps r√©el** : uniquement pour les nouveaux √©v√©nements
2. **Client contr√¥le le chargement** : d√©cide quand charger/recharger
3. **Pas de duplication** : s√©paration claire entre historique et temps r√©el

## Flow client d√©taill√©

### Sc√©nario 1 : Chargement initial d'un thread

```typescript
// 1. Charger l'historique
const history = await messageApi.getMessages(projectName, threadId)
codayService.loadMessages(history.messages)  // Avec d√©duplication

// 2. S'abonner aux mises √† jour temps r√©el
eventStream.connectToThread(projectName, threadId)
```

### Sc√©nario 2 : Reconnexion apr√®s perte r√©seau

```typescript
// Les messages sont d√©j√† en m√©moire (messagesSubject)
// Pas besoin de recharger l'historique

// Juste reconnecter le SSE
eventStream.connectToThread(projectName, threadId)

// Les nouveaux √©v√©nements arriveront via broadcast
// La d√©duplication c√¥t√© client emp√™che les doublons
```

### Sc√©nario 3 : Changement d'onglet (focus/blur)

```typescript
// Option A : Garder la connexion SSE active (navigateur g√®re)
// ‚Üí Pas de reconnexion, pas de probl√®me

// Option B : Si le navigateur ferme le SSE
// ‚Üí M√™me flow que Sc√©nario 2 (reconnexion sans rechargement)
```

### Sc√©nario 4 : Rechargement explicite par l'utilisateur

```typescript
// L'utilisateur demande explicitement √† recharger le thread
codayService.resetMessages()
const history = await messageApi.getMessages(projectName, threadId)
codayService.loadMessages(history.messages)
```

## Impl√©mentation par phases

### Phase 1 : D√©duplication c√¥t√© client ‚úÖ (FAIT)

- Ajout de la d√©duplication dans `addMessage()`
- Ajout de `loadMessages()` pour chargement bulk
- Logs d√©taill√©s pour tracer les duplications

### Phase 2 : D√©sactiver le replay automatique

```typescript
// Dans thread-coday-manager.ts
addConnection(response: Response): void {
  // ... existing code ...
  
  // REMOVE this block:
  // if (this.coday && isReconnection && wasDisconnected) {
  //   this.replayThreadHistory(response)
  // }
}
```

### Phase 3 : Cr√©er l'endpoint GET /messages

```typescript
// Dans thread.routes.ts
app.get('/api/projects/:projectName/threads/:threadId/messages', 
  async (req, res) => {
    const { projectName, threadId } = req.params
    const username = getUsernameFn(req)
    
    // Get thread
    const thread = await threadService.getThread(projectName, threadId)
    
    // Verify ownership
    if (thread.username !== username) {
      return res.status(403).json({ error: 'Access denied' })
    }
    
    // Get messages from thread
    const messages = thread.getAllMessages()  // ou getMessages() selon besoin
    
    res.json({
      messages,
      threadInfo: {
        id: thread.id,
        name: thread.name,
        messageCount: messages.length,
        modifiedDate: thread.modifiedDate
      }
    })
  }
)
```

### Phase 4 : Modifier le client pour utiliser le nouvel endpoint

```typescript
// Dans thread.component.ts
private async initializeThreadConnection(): Promise<void> {
  // 1. Charger l'historique d'abord
  try {
    const history = await this.messageApi.getMessages(
      this.projectName, 
      this.threadId
    ).toPromise()
    
    this.codayService.loadMessages(history.messages)
  } catch (error) {
    console.error('[THREAD] Failed to load history:', error)
  }
  
  // 2. Puis s'abonner aux √©v√©nements temps r√©el
  this.codayService.connectToThread(this.projectName, this.threadId)
}
```

## Questions ouvertes

### Q1 : Faut-il garder `replayThreadHistory()` pour certains cas ?

**R√©ponse sugg√©r√©e** : NON
- Le GET /messages remplace compl√®tement le replay
- Plus simple, plus pr√©visible, plus contr√¥lable

### Q2 : Que faire des tr√®s longs threads (> 1000 messages) ?

**R√©ponse sugg√©r√©e** : Commencer simple (Option A), optimiser plus tard si n√©cessaire
- La plupart des threads ont < 100 messages
- Si probl√®me de performance : impl√©menter Option C (messages r√©cents)
- √âviter l'optimisation pr√©matur√©e

### Q3 : Comment g√©rer les SummaryEvent ins√©r√©s au milieu ?

**R√©ponse sugg√©r√©e** : La d√©duplication par ID r√©sout le probl√®me
- Chaque √©v√©nement a un timestamp unique (ID)
- Peu importe o√π il est ins√©r√© dans la chronologie
- La d√©duplication emp√™che les doublons

### Q4 : Faut-il un indicateur de chargement pendant GET /messages ?

**R√©ponse sugg√©r√©e** : OUI
```typescript
// Dans thread.component.ts
isLoadingHistory: boolean = false

private async initializeThreadConnection(): Promise<void> {
  this.isLoadingHistory = true
  try {
    const history = await this.messageApi.getMessages(...)
    this.codayService.loadMessages(history.messages)
  } finally {
    this.isLoadingHistory = false
  }
  
  this.codayService.connectToThread(...)
}
```

## D√©cision recommand√©e

**Approche progressive** :

1. ‚úÖ **D√©duplication c√¥t√© client** (FAIT) - Protection imm√©diate
2. ‚è≥ **Cr√©er GET /messages** (Option A - simple) - Nouveau endpoint
3. ‚è≥ **Modifier le client** pour utiliser GET /messages avant SSE
4. ‚è≥ **D√©sactiver le replay automatique** - Simplification
5. üîÆ **Optimisation future** si besoin (pagination, etc.)

Cette approche :
- R√©sout le probl√®me de duplication **imm√©diatement** (Phase 1)
- S√©pare les responsabilit√©s **proprement** (Phases 2-4)
- Reste **simple** et **√©volutive** (pas de sur-ing√©nierie)
- Suit le principe **YAGNI** (You Aren't Gonna Need It)

## Prochaines √©tapes

1. **Tester la d√©duplication actuelle** en conditions r√©elles
2. **D√©cider de l'option d'API** (A, B ou C)
3. **Impl√©menter l'endpoint GET /messages**
4. **Modifier le client** pour charger l'historique avant SSE
5. **D√©sactiver le replay automatique**
6. **Monitorer et ajuster** si n√©cessaire
